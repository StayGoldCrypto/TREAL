/* Auto generated by cargo new --lib trs_token
pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}

 */

use gstd::prelude::*;
use gstd::{msg, exec, ActorId};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct TRSToken {
    owner: ActorId,
    total_supply: u128,
    balances: BTreeMap<ActorId, u128>,
}

impl TRSToken {
    pub fn new(total_supply: u128) -> Self {
        let owner = msg::source();
        let mut balances = BTreeMap::new();
        balances.insert(owner, total_supply);
        Self {
            owner,
            total_supply,
            balances,
        }
    }

    pub fn transfer(&mut self, to: ActorId, amount: u128) -> Result<(), &'static str> {
        let sender = msg::source();
        let sender_balance = self.balances.get(&sender).copied().unwrap_or(0);
        if sender_balance < amount {
            return Err("Insufficient balance");
        }
        self.balances.insert(sender, sender_balance - amount);
        let recipient_balance = self.balances.get(&to).copied().unwrap_or(0);
        self.balances.insert(to, recipient_balance + amount);
        Ok(())
    }

    pub fn balance_of(&self, owner: ActorId) -> u128 {
        *self.balances.get(&owner).unwrap_or(&0)
    }
}

// Entry point
#[no_mangle]
pub extern "C" fn handle() {
    let action: &str = msg::load().unwrap();
    let token = exec::state_mut::<TRSToken>();
    match action {
        "new" => {
            let initial_supply: u128 = msg::load().unwrap();
            *token = TRSToken::new(initial_supply);
        }
        "transfer" => {
            let (to, amount): (ActorId, u128) = msg::load().unwrap();
            token.transfer(to, amount).unwrap();
        }
        _ => (),
    }
}
